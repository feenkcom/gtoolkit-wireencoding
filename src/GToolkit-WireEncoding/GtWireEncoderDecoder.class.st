Class {
	#name : #GtWireEncoderDecoder,
	#superclass : #Object,
	#instVars : [
		'stream',
		'map',
		'reverseMap'
	],
	#classVars : [
		'GtDefaultMap',
		'GtDefaultReverseMap'
	],
	#category : #'GToolkit-WireEncoding'
}

{ #category : #maintenance }
GtWireEncoderDecoder class >> generateDefaultGsMapMethod [
	"Generate and save the defaultMap method for GS.
	Traversing a class hierarchy is very expensive, especially on GemStone.
	Generate a method to create the map by traversing the required class hierarchies."
	| mapping source |
	
	mapping := self defaultMapping.
	source := self generateDefaultGsMapMethodFrom: mapping.
	"How to compile on GemStone when under Rowan control?"
	"self class
		compileMethod: source
		dictionaries: GsCurrentSession currentSession symbolList
		category: '*GToolkit-WireEncoding-GemStone'
		environmentId: 0."
	^ source
]

{ #category : #maintenance }
GtWireEncoderDecoder class >> generateDefaultGsMapMethodFrom: aDictionary [
	"Answer the source code for the #defaultMap method from the supplied map dictionary.
	.gs files don't allow undeclared classes to be referenced... 
	hack around it by deferring class lookup."
	| source |

	source := String streamContents: [ :stream |
		stream
			<< 'getDefaultMap'; lf;
			tab; << '"Generated by #generateDefaultMapMethodFrom:.'; lf;
			tab; << 'Original source is #defaultMapping, changes should be made there and the code regenerated."'; lf;
			lf;
			tab; << '^ IdentityDictionary new'; lf.
		(aDictionary keys asSortedCollection: [ :a :b | a name < b name ]) do: [ :key |
				stream
					tab; tab; << 'at: ((self lookupClass: #';
					<< key name;
					<< (') ifNil: [ self error: ''Unable to find: ', key name asString, ''' ]) put: ');
					<< (aDictionary at: key) class name;
					<< ' new' ]
			separatedBy: [ stream << ';'; lf ].
		stream
			<< ';'; lf;
			tab; tab; << 'yourself.'; lf ].
	^ source
]

{ #category : #maintenance }
GtWireEncoderDecoder class >> generateDefaultGsReverseMapMethod [
	"Generate and save the defaultMap method for GS.
	Traversing a class hierarchy is very expensive, especially on GemStone.
	Generate a method to create the map by traversing the required class hierarchies."
	| reverse source |
	
	reverse := self reverseMapFrom: self defaultMapping.
	source := self generateDefaultReverseMapMethodFrom: reverse.
	"How to compile on GemStone when under Rowan control?"
	"self class
		compileMethod: source
		dictionaries: GsCurrentSession currentSession symbolList
		category: '*GToolkit-WireEncoding-GemStone'
		environmentId: 0."
	^ source
]

{ #category : #maintenance }
GtWireEncoderDecoder class >> generateDefaultGtMapMethod [
	"Generate and save the defaultMap method for Gt.
	Traversing a class hierarchy is very expensive, especially on GemStone.
	Generate a method to create the map by traversing the required class hierarchies."
	| mapping source reverse |

	mapping := self defaultMapping.
	source := self generateDefaultMapMethodFrom: mapping.
	self class
		compile: source
		classified: '*GToolkit-WireEncoding-GT'.

	reverse := self reverseMapFrom: mapping.
	source := self generateDefaultReverseMapMethodFrom: reverse.
	self class
		compile: source
		classified: '*GToolkit-WireEncoding-GT'.
	self  initialize.
]

{ #category : #maintenance }
GtWireEncoderDecoder class >> generateDefaultMapMethodFrom: aDictionary [
	"Answer the source code for the #defaultMap method from the supplied map dictionary"
	| source |

	source := String streamContents: [ :stream |
		stream
			<< 'getDefaultMap'; lf;
			tab; << '"Generated by #generateDefaultMapMethodFrom:.'; lf;
			tab; << 'Original source is #defaultMapping, changes should be made there and the code regenerated."'; lf;
			lf;
			tab; << '^ IdentityDictionary new'; lf.
		(aDictionary keys asSortedCollection: [ :a :b | a name < b name ]) do: [ :key |
				stream
					tab; tab; << 'at: ';
					<< key name;
					<< ' put: ';
					<< (aDictionary at: key) class name;
					<< ' new' ]
			separatedBy: [ stream << ';'; lf ].
		stream
			<< ';'; lf;
			tab; tab; << 'yourself.'; lf ].
	^ source
]

{ #category : #maintenance }
GtWireEncoderDecoder class >> generateDefaultReverseMapMethodFrom: aDictionary [
	"Answer the source code for the #defaultMap method from the supplied map dictionary"
	| source |

	source := String streamContents: [ :stream |
		stream
			<< 'getDefaultReverseMap'; lf;
			tab; << '"Generated by #generateDefaultReverseMapMethodFrom:.'; lf;
			tab; << 'Original source is #defaultMapping, changes should be made there and the code regenerated."'; lf;
			lf;
			tab; << '^ IdentityDictionary new'; lf.
		aDictionary keys asSortedCollection do: [ :key |
				stream
					tab; tab; << 'at: ';
					<< key asString;
					<< ' put: ';
					<< (aDictionary at: key) class name;
					<< ' new' ]
			separatedBy: [ stream << ';'; lf ].
		stream
			<< ';'; lf;
			tab; tab; << 'yourself.'; lf ].
	^ source
]

{ #category : #initialization }
GtWireEncoderDecoder class >> initialize [
	"NOTE: GtDefaultMap and GtDefaultReverseMap should only be used on GT.
	On GemStone they should always be nil."

	GtDefaultMap := GtDefaultReverseMap := nil
]

{ #category : #private }
GtWireEncoderDecoder class >> lookupClass: className [
	"Answer the class with the supplied name or nil if not found.
	For GemStone, see STONReader>>lookupClass: for inspiration."

	^ self
		gtDo: [ self class environment classOrTraitNamed: className ]
		gemstoneDo: [ System myUserProfile objectNamed: className asSymbol ]
]

{ #category : #private }
GtWireEncoderDecoder class >> map: aClass withSubclassesTo: anEncoder in: mapping [
	"Add the mapping for aClass and all its subclasses"
	
	"GemStone doesn't have #withAllSubclasses"
	mapping at: aClass put: anEncoder.
	aClass allSubclasses do: [ :cls |
		mapping at: cls put: anEncoder ].
]

{ #category : #accessing }
GtWireEncoderDecoder class >> reverseMapFrom: aDictionary [
	"Construct the reverse map.
	Build a default reverse map and then  overwrite with the supplied configured encoders."
	| reverseMap |

	reverseMap := IdentityDictionary new.
	GtWireObjectEncoder allSubclasses do: [ :cls |
		cls typeIdentifierOrNil ifNotNil:
			[ :id | reverseMap at: id put: cls new ] ].
	aDictionary associationsDo: [ :assoc |
		assoc value class typeIdentifierOrNil ifNotNil: [ :id |
			reverseMap at: id put: assoc value ] ].
	^ reverseMap

]

{ #category : #accessing }
GtWireEncoderDecoder >> addMapping: aClass to: anEncoder [
	"Add/Overwrite the supplied encoder.
	Be careful not to accidentally overwrite the default map unintentionally."
	| typeIdentifier |
	
	self map at: aClass put: anEncoder.
	typeIdentifier := anEncoder class typeIdentifierOrNil.
	typeIdentifier ifNotNil:
		[ self reverseMap at: typeIdentifier put: anEncoder ]
]

{ #category : #accessing }
GtWireEncoderDecoder >> contents [

	^ stream contents
]

{ #category : #accessing }
GtWireEncoderDecoder >> map [

	^ map ifNil: [ map := self class defaultMap copy ]
]

{ #category : #accessing }
GtWireEncoderDecoder >> map: aDictionary [

	map := aDictionary.
	reverseMap := nil.
]

{ #category : #'private - helpers' }
GtWireEncoderDecoder >> replaceMappingsMatching: matchBlock with: replacementBlock [
	"Replace all the mappings matching matchBlock with the encoder returned by replacementBlock.
	Used by examples to avoid needing live servers."

	self map associationsDo: [ :assoc |
		(matchBlock value: assoc value) ifTrue:
			[ assoc value: replacementBlock value ]
		ifFalse:
			[ assoc value replaceMappingsMatching: matchBlock with: replacementBlock ] ]
]

{ #category : #initialization }
GtWireEncoderDecoder >> reset [

	stream reset
]

{ #category : #accessing }
GtWireEncoderDecoder >> reverseMap [

	^ reverseMap ifNil: [ reverseMap := self class reverseMapFrom: self map ]
]

{ #category : #accessing }
GtWireEncoderDecoder >> reverseMap: anObject [
	reverseMap := anObject
]

{ #category : #accessing }
GtWireEncoderDecoder >> stream [

	^ stream ifNil: [ stream := GtWireStream on:
		(ByteArray new: 64 * 1024) ]
]

{ #category : #accessing }
GtWireEncoderDecoder >> stream: aGtWireReadWriteStream [

	stream := aGtWireReadWriteStream
]
